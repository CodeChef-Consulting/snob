// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

generator trpc {
  provider = "prisma-trpc-generator"
  config   = "./trpc.config.json"
  output   = "../../../apps/server/src/generated"
}

generator zod {
  provider                         = "prisma-zod-generator"
  output                           = "../../../apps/server/src/generated"
  createOptionalDefaultValuesTypes = true
  createRelationValuesTypes        = true
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Post {
  id                Int              @id @default(autoincrement())
  externalId        String           @unique
  subreddit         String
  author            String?
  title             String?
  body              String?
  score             Int?
  ups               Int?
  downs             Int?
  upvoteRatio       Float?
  numComments       Int?
  gilded            Int?
  permalink         String?
  createdUtc        DateTime?
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  scrapingSession   ScrapingSession? @relation(fields: [scrapingSessionId], references: [id])
  scrapingSessionId Int?

  // Comment scraping tracking
  commentsLastScrapedAt DateTime? // When comments were last fetched
  commentsFullyScraped  Boolean   @default(false) // All nested comments fetched

  comments             Comment[]
  files                File[]
  restaurantsMentioned Restaurant[]
  restaurantExtraction RestaurantExtraction?
  sentimentExtraction  SentimentExtraction?

  @@index([scrapingSessionId])
  @@index([commentsFullyScraped]) // For querying posts that need comment scraping
}

model Comment {
  id                Int              @id @default(autoincrement())
  externalId        String           @unique
  post              Post             @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId            Int
  parentComment     Comment?         @relation("CommentReplies", fields: [parentCommentId], references: [id], onDelete: Cascade)
  parentCommentId   Int?
  replies           Comment[]        @relation("CommentReplies")
  author            String?
  body              String?
  score             Int?
  ups               Int?
  depth             Int?
  controversiality  Int?
  isSubmitter       Boolean?
  scoreHidden       Boolean?
  permalink         String?
  createdUtc        DateTime?
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  scrapingSession   ScrapingSession? @relation(fields: [scrapingSessionId], references: [id])
  scrapingSessionId Int?

  files                File[]
  restaurantsMentioned Restaurant[]
  restaurantExtraction RestaurantExtraction?
  sentimentExtraction  SentimentExtraction?

  @@index([scrapingSessionId])
}

model File {
  id        Int      @id @default(autoincrement())
  post      Post?    @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId    Int?
  comment   Comment? @relation(fields: [commentId], references: [id], onDelete: Cascade)
  commentId Int?
  fileUrl   String
  fileType  String
  metadata  Json?
  createdAt DateTime @default(now())

  @@unique([postId, fileUrl], name: "postId_fileUrl")
  @@unique([commentId, fileUrl], name: "commentId_fileUrl")
}

model Restaurant {
  id            Int      @id @default(autoincrement())
  name          String
  address       String?
  city          String?
  state         String?
  zipCode       String?
  source        String   @default("Open Data Portal") // "Open Data Portal" or "Google Places API"
  googlePlaceId String?  @unique // Google Places ID for API lookups
  lookupAliases String? // Comma-separated list of alternative names for exact matching (Google Places only)
  metadata      Json? // Store additional data (phone, website, rating, priceLevel, types, etc.)
  rawScore      Float? // Raw mathematical score from sentiment analysis (unbounded, typically -20 to +20)
  normalizedScore Float? // Normalized score 0-10, centered at 7 (computed from rawScore distribution)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  posts    Post[]
  comments Comment[]

  @@index([source])
  @@index([googlePlaceId])
  @@index([rawScore])
  @@index([normalizedScore])
}

model BatchJob {
  id Int @id @default(autoincrement())

  // Gemini Batch API details
  geminiJobName String? @unique // e.g., "batches/123456789"
  displayName   String // Human-readable name
  model         String // e.g., "gemini-2.5-flash"

  // Job configuration
  contentType String // "post" or "comment"
  itemCount   Int // Number of items in batch
  itemIds     Json // Array of post/comment IDs in this batch

  // Status tracking
  status      String    @default("pending") // pending, submitted, running, succeeded, failed, cancelled, expired
  submittedAt DateTime?
  completedAt DateTime?

  // Result processing
  extractionsSaved   Boolean   @default(false) // Whether results were saved to RestaurantExtraction
  extractionsSavedAt DateTime?
  successCount       Int       @default(0)
  errorCount         Int       @default(0)

  // Error tracking
  error String? // Error message if failed

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
  @@index([contentType])
  @@index([extractionsSaved])
  @@index([createdAt])
}

model RestaurantExtraction {
  id Int @id @default(autoincrement())

  // Link to either post or comment (one must be set)
  post      Post?    @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId    Int?
  comment   Comment? @relation(fields: [commentId], references: [id], onDelete: Cascade)
  commentId Int?

  // Extraction results (matching RestaurantExtractionResult interface)
  restaurantsMentioned String? // Comma-separated or "NONE"
  primaryRestaurant    String? // Single restaurant name or "NONE"
  dishesMentioned      String? // Comma-separated or "NONE"
  isSubjective         Boolean

  // Linking tracking
  attemptedLinkToRestaurantsMentioned Boolean @default(false) // Whether we've attempted to link this extraction

  // Metadata
  extractedAt DateTime @default(now())
  model       String? // e.g., "gemini-2.5-flash"

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([postId]) // One extraction per post
  @@unique([commentId]) // One extraction per comment
  @@index([isSubjective]) // For filtering subjective content
  @@index([extractedAt]) // For tracking extraction progress
  @@index([attemptedLinkToRestaurantsMentioned]) // For querying items that need linking
}

model SentimentExtraction {
  id Int @id @default(autoincrement())

  // Link to either post or comment (one must be set)
  post      Post?    @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId    Int?
  comment   Comment? @relation(fields: [commentId], references: [id], onDelete: Cascade)
  commentId Int?

  // Sentiment score (-1 to 1)
  rawAiScore Float?

  // Metadata
  extractedAt DateTime @default(now())
  model       String? // e.g., "gemini-2.5-flash"

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([postId]) // One sentiment per post
  @@unique([commentId]) // One sentiment per comment
  @@index([rawAiScore]) // For filtering by sentiment
  @@index([extractedAt]) // For tracking extraction progress
}

model ScrapingSession {
  id          Int     @id @default(autoincrement())
  subreddit   String
  mode        String  @default("new") // new, top, controversial, search
  timeframe   String? // all, year (for top/controversial/search)
  searchQuery String? // for search mode

  // Post scraping tracking only
  lastPostId        String? // Last post processed (for resumability)
  lastPostTimestamp DateTime? // Timestamp of last post processed
  postsScraped      Int       @default(0)
  completed         Boolean   @default(false) // All posts scraped

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  posts    Post[]
  comments Comment[]

  @@index([subreddit, mode, timeframe, searchQuery])
  @@index([createdAt])
  @@index([completed])
}
